[{"id":0,"href":"/LSUClient-docs/docs/getting-started/examples/","title":"Basic Examples","section":"Getting Started","content":"Basic Examples #  These are some examples to try out. For all available parameters and guidance on how to use them run Get-Help -Detailed on the functions in this module.\nGet available updates #  Get-LSUpdate Get and install available updates #  $updates = Get-LSUpdate $updates | Install-LSUpdate -Verbose Get and install available updates, with some simple progress output #  $updates = Get-LSUpdate $i = 1 foreach ($update in $updates) { Write-Host \u0026#34;Installing update $i of $($updates.Count): $($update.Title)\u0026#34; Install-LSUpdate -Package $update -Verbose $i++ } Install only packages that can be installed silently and non-interactively #  $updates = Get-LSUpdate | Where-Object { $_.Installer.Unattended } $updates | Save-LSUpdate -Verbose $updates | Install-LSUpdate -Verbose Filtering out non-unattended packages like this is strongly recommended when using this module in MDT, SCCM, PDQ, remote execution via PowerShell Remoting, ssh or any other situation in which you run these commands remotely or as part of an automated process. Packages with installers that are not unattended may force reboots or attempt to start a GUI setup on the machine and, if successful, halt until someone clicks through the dialogs.\nGet all available packages #  $updates = Get-LSUpdate -All By default, Get-LSUpdate only returns \u0026ldquo;needed\u0026rdquo; updates. Needed updates are those that are applicable to the system and not yet installed. If you want to retrieve all available packages instead, use Get-LSUpdate -All. To filter out unneeded packages later, just look at the IsApplicable and IsInstalled properties. The default logic is equivalent to: Get-LSUpdate -All | Where-Object { $_.IsApplicable -and -not $_.IsInstalled }\nDownload drivers for another computer #  Get-LSUpdate -Model \u0026#39;20LS\u0026#39; -All | Save-LSUpdate -Path \u0026#39;C:\\Drivers\\20LS\u0026#39; -ShowProgress Using the -Model parameter of Get-LSUpdate you can retrieve packages for another computer model. In this case you almost always want to use -All too so that the packages found are not filtered against your computer and all packages are downloaded.\nEver since LSUClient Version 1.3.3 you can also pass full-length MTM/model names such as 20K70000GE to this parameter.\n"},{"id":1,"href":"/LSUClient-docs/docs/getting-started/best-practices/","title":"Best Practices","section":"Getting Started","content":"Best Practices #  1. Search for and install updates a few times in a loop #  Some packages and updates depend on others already being installed, so they might not show up during the first search for updates. If you want to make sure \u0026ldquo;everything\u0026rdquo; has been installed and/or updated it is best to re-run Get-LSUpdate and Install-LSUpdate a few times or until no more updates are found.\n2. Download all packages before starting to install any #  Installing a network (NIC, WiFi adapter) driver can cause a short loss of network connectivity. When you feed packages found by Get-LSUpdate directly to Install-LSUpdate they will each be individually downloaded and then installed, therefore a network driver installation can cause the following package downloads to fail. Downloading all packages you intend to install beforehand with Save-LSUpdate will prevent this potential problem.\nIf you download packages to a custom location with Save-LSUpdate -Path you have to pass the same path to Install-LSUpdate -Path for it to find the previously downloaded files. If Install-LSUpdate cannot find the expected files locally it will still attempt to fetch them from the repository.  3. Write your own logfile #  LSUClient is a PowerShell module, so you will utilize it by scripting around the functionality it exposes, adding your own logic, filtering, workarounds or special cases according to your requirements. Unexpected behavior and errors can occur both within your scripts and within the functions from LSUClient, so a good logfile that details what is happening and allows you to find the source of a problem in retrospect is a must.\nIf you don\u0026rsquo;t know where to start, start with Start-Transcript to log whatever is being output to the console. If you would like more insight into what LSUClient is doing, add the common -Verbose parameter to the cmdlets you run. If you are intimately familiar with Lenovos package XML format, perhaps even the output of Get-LSUpdate -Verbose -Debug will be useful to you.\n"},{"id":2,"href":"/LSUClient-docs/docs/getting-started/bios-and-firmware/","title":"BIOS/UEFI and Firmware updates","section":"Getting Started","content":"BIOS/UEFI and other firmware updates #  LSUClient will install BIOS/UEFI updates silently when possible.\nLike with any other package, those for which a silent installation is supported will have their .Installer.Unattended property set to $True. If you get a BIOS/UEFI update for which .Installer.Unattended is $False, that means it uses a type of installer/flasher for which either no silent install options exist or for which LSUClient doesn\u0026rsquo;t support performing silent installs yet.\nWhen you install such a non-silent package its setup routine will be invoked with the default arguments in the same way System Update would.\nLikely this will mean a graphical wizard will come up and wait for you to confirm or cancel the update.\nHandling reboots #  It is important to know that some Lenovo computers require a reboot to apply BIOS updates while other models require a shutdown - the BIOS will then wake the machine from the power-off state, apply the update and boot back into Windows. Other, non-BIOS firmware updates typically always require a reboot. So as to not interrupt a deployment or someone working, this module will never initiate reboots or shutdowns on its own, however it\u0026rsquo;s easy for you to:\n  Capture the PackageInstallResult objects returned by Install-LSUpdate, e.g.:\n[array]$results = Install-LSUpdate -Package $updates   Then test for the PendingAction values REBOOT_MANDATORY or SHUTDOWN and handle them in your script:\nif ($results.PendingAction -contains \u0026#39;REBOOT_MANDATORY\u0026#39;) { # reboot immediately or set a marker for yourself to perform the reboot shortly } if ($results.PendingAction -contains \u0026#39;SHUTDOWN\u0026#39;) { # shutdown immediately or set a marker for yourself to perform the shutdown shortly } If you prefer to loop through the updates one-by-one and handle their result immediately, you can use -eq or a switch statement:\nforeach ($update in $updates) { $result = Install-LSUpdate -Package $update switch ($result.PendingAction) { # your logic here } }   SaveBIOSUpdateInfoToRegistry Parameter #  This parameter is deprecated and only documented for the sake of helping move existing scripts away from it.\nIt may be removed in a future major release of LSUClient. Use the technique described above instead.\n There is also a -SaveBIOSUpdateInfoToRegistry parameter on Install-LSUpdate.\nPrior to version 1.4.0, this used to be the only way for LSUClient to communicate a required power cycle back to you.\nWhen Install-LSUpdate is called with this parameter and it successfully installs a BIOS update, it will write some registry keys to HKLM\\Software\\LSUClient\\BIOSUpdate, including the string ActionNeeded which will contain either \u0026quot;REBOOT\u0026quot; or \u0026quot;SHUTDOWN\u0026quot;.\nHowever, using the -SaveBIOSUpdateInfoToRegistry parameter is no longer recommended because, as the name implies, it only sets those registry keys when installing BIOS/UEFI updates and not for any other kinds of firmware updates that might require a reboot just the same.\nTo summarize the differences and aid the transition, the following table compares the values to expect in different scenarios:\n   Scenario PendingAction property \u0026ldquo;ActionNeeded\u0026rdquo; registry value set by -SaveBIOSUpdateInfoToRegistry     ThinkPad BIOS update REBOOT_MANDATORY REBOOT   ThinkCentre BIOS update SHUTDOWN SHUTDOWN   Any Reboot Type 5 update REBOOT_MANDATORY    Any Reboot Type 3 update REBOOT_SUGGESTED    Any Reboot Type 0 update NONE    Any unsuccessful update NONE     As you can see, the PendingAction property is always set and more explicit and granular in communicating whether a power cycle is needed or not.\nExcluding BIOS and/or firmware updates #  If you want to simply not install any BIOS/UEFI updates, I recommend filtering them by Type and possibly Category and Title as a fallback.\nNot all packages have type information, sometimes Type is $null so don\u0026rsquo;t rely on this property alone  Packages sourced from internal repositories created with \u0026ldquo;Lenovo Update Retriever\u0026rdquo; never have Category information.\nIn that scenario it is best to either not include BIOS updates in your repository at all or to filter them by their IDs before installing.\n Filtering out BIOS/UEFI updates:\n$updates = Get-LSUpdate | Where-Object { $_.Type -ne \u0026#39;BIOS\u0026#39; } | Where-Object { $_.Category -notmatch \u0026#34;BIOS|UEFI\u0026#34; } | Where-Object { $_.Title -notmatch \u0026#34;BIOS|UEFI\u0026#34; } Filtering out other firmware updates:\n$updates = Get-LSUpdate | Where-Object { $_.Type -ne \u0026#39;Firmware\u0026#39; } | Where-Object { $_.RebootType -ne 5 } | Where-Object { $_.Category -notlike \u0026#34;*Firmware*\u0026#34; } | Where-Object { $_.Title -notlike \u0026#34;*Firmware*\u0026#34; } Recommended reading #  https://support.lenovo.com/de/en/solutions/ht507859-bios-flashing-sccm-support-thinkcentre-thinkstation\nhttps://thinkdeploy.blogspot.com/2019/06/what-are-reboot-delayed-updates.html\n"},{"id":3,"href":"/LSUClient-docs/docs/getting-started/versioning/","title":"Versioning","section":"Getting Started","content":"Versioning #  LSUClient uses a three-part version number MAJOR.MINOR.PATCH and follows SemVer 2.0.0.\nThis means you can generally expect all your scripts and integrations to keep working with any one major version (such as 1.x.x).\nThere is only ever one current release of LSUClient, there is no parallel maintenance of older releases or prior versions. As soon as a new release is out the prior one is obsoleted.\nWhat is and isn\u0026rsquo;t covered by the semantic versioning promise #  Semantic versioning communicates changes in a softwares \u0026ldquo;public API\u0026rdquo;.\nFor the purpose of a PowerShell Module, the public API is the exported functions (cmdlets), classes and the returned objects.\nExplicitly exempt from this public API are:\n Private functions Internal classes Hidden properties Output streams other than the success stream (1)  The data structure, type, name, content and behavior of these may change at any point without notice as they are only intended for internal use by LSUClient itself, or in the case of non-success output streams such as Verbose and Debug, only for logging and \u0026ldquo;human consumption\u0026rdquo; and not to support scripting workloads.\nMinor breaking changes in minor versions #  I must admit, I sometimes make exceptions from this rule for breaking changes I consider to be \u0026ldquo;very very minor\u0026rdquo; in that:\n I feel they are likely not going to impact any or only very few users They are trivial to adjust for, as in the change(s) required to get everything working again with the new version are very very small  An example of this is the change of the type of the URL property on the [LenovoUpdate] objects from [System.Uri] to [System.String] with Version 1.3.0. So if you were accessing a property or method unique to the [System.Uri] object, for example:\n# Pretend-script written for LSUClient 1.2.5 $OneUpdate = Get-LSUpdate -All | Select-Object -First 1 if ($OneUpdate.URL.Host -like \u0026#34;*.com\u0026#34;) { Write-Output \u0026#34;Hey! This update was sourced from a .com domain!\u0026#34; } else { Write-Output \u0026#34;Some other domain!\u0026#34; } that would have broken because once $OneUpdate.URL became a string, it no longer had a Host property.\nThis means in the code snippet above $OneUpdate.URL.Host will evaluate to $null and either always print Some other domain! or error with The property 'Host' cannot be found on this object. if you are running in PowerShell Strict Mode.\nHowever, a quick fix to get the same snippet working again could be to just cast $OneUpdate.URL back to [System.Uri]:\n# Pretend-script updated for LSUClient 1.3.0+ $OneUpdate = Get-LSUpdate -All | Select-Object -First 1 if (([Uri]$OneUpdate.URL).Host -like \u0026#34;*.com\u0026#34;) { Write-Output \u0026#34;Hey! This update was sourced from a .com domain!\u0026#34; } else { Write-Output \u0026#34;Some other domain!\u0026#34; } Any such \u0026ldquo;minor breaking change\u0026rdquo; will be noted in the release notes, and will also be accompanied by a bump of the MINOR version number.\n"}]