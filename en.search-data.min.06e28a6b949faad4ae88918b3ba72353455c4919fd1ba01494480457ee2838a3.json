[{"id":0,"href":"/LSUClient-docs/docs/topics/examples/","title":"Getting Started","section":"Topics","content":" Getting Started # LSUClient has two main cmdlets: Get-LSUpdate and Install-LSUpdate - they basically do what their name implies!\nThese are some examples to get started with. To see all available parameters of each cmdlet and guidance on how to use them either see the online Cmdlet Reference in the navigation bar on the left or install the module and use Get-Help -Detailed or tab-completion to explore the cmdlets.\nGet available updates for the system # Get-LSUpdate Get and install available updates # $updates = Get-LSUpdate $updates | Install-LSUpdate -Verbose Install only packages that can be installed silently and non-interactively # 1 2 3 $updates = Get-LSUpdate | Where-Object { $_.Installer.Unattended } $updates | Save-LSUpdate -Verbose $updates | Install-LSUpdate -Verbose Filtering out non-unattended packages like this is strongly recommended when using this module in MDT, SCCM, PDQ, remote execution via PowerShell Remoting, ssh or any other situation in which you run these commands remotely or as part of an automated process. Packages with installers that are not unattended may force reboots or attempt to start a GUI setup on the machine and, if successful, halt until someone clicks through the dialogs.\nGet and install available updates, with some basic progress output # 1 2 3 4 5 6 7 8 $updates = Get-LSUpdate $updates | Save-LSUpdate -Verbose $i = 1 foreach ($update in $updates) { Write-Host \u0026#34;Installing update $i of $($updates.Count): $($update.Title)\u0026#34; Install-LSUpdate -Package $update -Verbose $i++ } Get all available packages # $updates = Get-LSUpdate -All By default, Get-LSUpdate only returns \u0026ldquo;needed\u0026rdquo; updates. Needed updates are those that are applicable to the system and not yet installed. If you want to retrieve all available packages instead, use Get-LSUpdate -All. This can be of interest if you want to re-install a driver package you believe may be broken or as a workaround when a package is detected as not applicable but you still want to install it (e.g. you might want to pre-install drivers for hardware such as an LTE modem or a docking station even though they are not currently connected to the machine). It is also possible to filter out the unneeded packages later by looking at the IsApplicable and IsInstalled properties. The default logic is equivalent to: Get-LSUpdate -All | Where-Object { $_.IsApplicable -and -not $_.IsInstalled }.\nDownload drivers for another computer model # Get-LSUpdate -Model \u0026#39;20LS\u0026#39; -All | Save-LSUpdate -Path \u0026#39;C:\\Drivers\\20LS\u0026#39; -ShowProgress Using the -Model parameter of Get-LSUpdate you can retrieve packages for another computer model. In this case you almost always want to use -All too so that the packages found are not filtered against your computer and all packages are downloaded.\nEver since LSUClient Version 1.3.3 you can also pass full-length MTM/model names such as 20K70000GE to this parameter.\n"},{"id":1,"href":"/LSUClient-docs/docs/topics/best-practices/","title":"Best Practices","section":"Topics","content":" Best Practices # 1. Search for and install updates a few times in a loop # Some packages and updates depend on others already being installed, so they might not show up during the first search for updates. If you want to make sure \u0026ldquo;everything\u0026rdquo; has been installed and/or updated it is best to re-run Get-LSUpdate and Install-LSUpdate a few times or until no more updates are found.\nExample This is a minimal example implementation of this best practice for demonstration purposes: ```powershell {linenos=table} $MaxRounds = 3 for ($Round = 1; $Round -le $MaxRounds; $Round++) { Write-Host \"Starting round $Round\" $updates = Get-LSUpdate Write-Host \"$($updates.Count) updates found\" if ($updates.Count -eq 0) { break; } $updates | Install-LSUpdate -Verbose } ``` 2. Download all packages before starting to install any # Installing a network (NIC, WiFi adapter) driver can cause a short loss of network connectivity. When you feed packages found by Get-LSUpdate directly to Install-LSUpdate they will each be individually downloaded and then installed, therefore a network driver installation can cause the following package downloads to fail (see GitHub issue #41). Downloading all packages you intend to install beforehand with Save-LSUpdate will prevent this potential problem.\nExample This is a minimal example implementation of this best practice for demonstration purposes: ```powershell {linenos=table} # Find updates $updates = Get-LSUpdate # Download them all to the local disk $updates | Save-LSUpdate # Then install $updates | Install-LSUpdate ``` If you download packages to a custom location with `Save-LSUpdate -Path` you have to pass that same path to `Install-LSUpdate -Path` in order for it to find the previously downloaded files. If `Install-LSUpdate` cannot find the expected files locally, it will still attempt to fetch them from the repository. 3. Write a logfile # Especially when running unattended or remotely, it is crucial to have a good logfile that details what happened and allows you to find the cause of a problem in retrospect.\nIf you don\u0026rsquo;t know where to start, start with Start-Transcript to log whatever is being output to the console. If you would like more insight into what LSUClient is doing, add the common -Verbose parameter to the cmdlets you run. If you are intimately familiar with Lenovos package XML format, perhaps even the output of Get-LSUpdate -Verbose -Debug will be useful to you.\nExample This is a minimal example implementation of this best practice for demonstration purposes: ```powershell {linenos=table} Start-Transcript -LiteralPath \"$env:TEMP\\lsuclient_$(Get-Date -Format 'yyyyMMdd-HHmmss').log\" $updates = Get-LSUpdate -Verbose Write-Host \"$($updates.Count) updates found\" $i = 1 foreach ($update in $updates) { Write-Host \"Installing update $i of $($updates.Count): $($update.Title)\" Install-LSUpdate -Package $update -Verbose $i++ } Stop-Transcript ``` 4. Keep $ErrorActionPreference set to Continue # Not every internal operation LSUClient carries out will and must neccesarily always succeed. Sometimes a file is in use by another process or just missing from Lenovos servers.\nErrors like these often only affect a single package out of many, and if they are severe enough that a particular package cannot be processed further then it will be skipped, but all other packages can still be processed normally. This is the behavior of PowerShells\u0026rsquo; default ErrorActionPreference setting: Continue. LSUClient does not attempt to silence or hide errors because they contain useful information about what went wrong and why. Particularly if you host your own package repository, any repository-related failures for example are important to know about so you can address them.\nSo while it is a common best practice for PowerShell scripts, with ErrorActionPreference set to Stop one of these \u0026ldquo;small\u0026rdquo; errors will always halt your entire script. Because of this I recommend against setting the ErrorActionPreference to Stop in your LSUClient scripts.\n"},{"id":2,"href":"/LSUClient-docs/docs/topics/bios-and-firmware/","title":"BIOS/UEFI and Firmware Updates","section":"Topics","content":" BIOS/UEFI and other Firmware Updates # LSUClient will install BIOS/UEFI updates silently when possible.\nLike with any other package, those for which a silent installation is supported will have their .Installer.Unattended property set to $True. If you get a BIOS/UEFI update for which .Installer.Unattended is $False, that means it uses a type of installer/flasher for which either no silent install options exist or for which LSUClient doesn\u0026rsquo;t support performing silent installs yet.\nWhen you install such a non-silent package its setup routine will be invoked with the default arguments in the same way System Update would.\nLikely this will mean a graphical wizard will come up and wait for you to confirm or cancel the update.\nHandling reboots # It is important to know that some Lenovo computers require a reboot to apply BIOS updates while other models require a shutdown - the BIOS will then wake the machine from the power-off state, apply the update and boot back into Windows. Other, non-BIOS firmware updates typically always require a reboot. So as to not interrupt a deployment or someone working, this module will never initiate reboots or shutdowns on its own, however it\u0026rsquo;s easy for you to:\nCapture the PackageInstallResult objects returned by Install-LSUpdate, e.g.:\n[array]$results = Install-LSUpdate -Package $updates Then test for the PendingAction values REBOOT_MANDATORY and SHUTDOWN and handle them in your script:\nif ($results.PendingAction -contains \u0026#39;REBOOT_MANDATORY\u0026#39;) { # reboot immediately or set a marker for yourself to perform the reboot shortly } if ($results.PendingAction -contains \u0026#39;SHUTDOWN\u0026#39;) { # shutdown immediately or set a marker for yourself to perform the shutdown shortly } If you prefer to loop through the updates one-by-one and handle their result immediately, you can use -eq or a switch statement:\nforeach ($update in $updates) { $result = Install-LSUpdate -Package $update switch ($result.PendingAction) { \u0026#39;REBOOT_MANDATORY\u0026#39; { # reboot immediately or set a marker for yourself to perform the reboot shortly } \u0026#39;SHUTDOWN\u0026#39; { # shutdown immediately or set a marker for yourself to perform the shutdown shortly } } } SaveBIOSUpdateInfoToRegistry Parameter # This parameter is deprecated and only documented for the sake of helping move existing scripts away from it. It may be removed in a future major release of LSUClient. Use the technique described [above](#handling-reboots) instead. There is also a -SaveBIOSUpdateInfoToRegistry parameter on Install-LSUpdate.\nPrior to version 1.4.0, this used to be the only way for LSUClient to communicate a required power cycle back to you.\nWhen Install-LSUpdate is called with this parameter and it successfully installs a BIOS update, it will write some registry keys to HKLM\\Software\\LSUClient\\BIOSUpdate, including the string ActionNeeded which will contain either \u0026quot;REBOOT\u0026quot; or \u0026quot;SHUTDOWN\u0026quot;.\nHowever, using the -SaveBIOSUpdateInfoToRegistry parameter is no longer recommended because, as the name implies, it only sets those registry keys when installing BIOS/UEFI updates and not for any other kinds of firmware updates that might require a reboot just the same.\nTo summarize the differences and aid the transition, the following table compares the values to expect in different scenarios:\nScenario PendingAction property \u0026ldquo;ActionNeeded\u0026rdquo; registry value set by -SaveBIOSUpdateInfoToRegistry ThinkPad BIOS update REBOOT_MANDATORY REBOOT ThinkCentre BIOS update SHUTDOWN SHUTDOWN Any Reboot Type 5 update REBOOT_MANDATORY Any Reboot Type 3 update REBOOT_SUGGESTED Any Reboot Type 0 update NONE Any unsuccessful update NONE As you can see, the PendingAction property is always set and more explicit and granular in communicating whether a power cycle is needed or not.\nExcluding BIOS and/or firmware updates # If you want to simply not install any BIOS/UEFI updates, I recommend filtering them by Type and possibly Category and Title as a fallback.\nNot all packages have type information, sometimes `Type` is `$null` so don't rely on this property alone Packages sourced from internal repositories created with \"Lenovo Update Retriever\" never have `Category` information. In that scenario it is best to either not have BIOS updates in your repository at all, make sure they always have their `Type` set correctly or to filter them by their IDs before installing. Filtering out BIOS/UEFI updates:\n$updates = Get-LSUpdate | Where-Object { $_.Type -ne \u0026#39;BIOS\u0026#39; } | Where-Object { $_.Category -notmatch \u0026#34;BIOS|UEFI\u0026#34; } | Where-Object { $_.Title -notmatch \u0026#34;BIOS|UEFI\u0026#34; } Filtering out other firmware updates:\n$updates = Get-LSUpdate | Where-Object { $_.Type -ne \u0026#39;Firmware\u0026#39; } | Where-Object { $_.RebootType -ne 5 } | Where-Object { $_.Category -notlike \u0026#34;*Firmware*\u0026#34; } | Where-Object { $_.Title -notlike \u0026#34;*Firmware*\u0026#34; } Recommended reading # https://support.lenovo.com/de/en/solutions/ht507859-bios-flashing-sccm-support-thinkcentre-thinkstation\nhttps://thinkdeploy.blogspot.com/2019/06/what-are-reboot-delayed-updates.html\n"},{"id":3,"href":"/LSUClient-docs/docs/topics/hanging-processes/","title":"Troubleshooting Hanging Processes","section":"Topics","content":" Hanging processes # By nature, LSUClient has to run and wait on external processes such as hardware-detection routines or driver installers to complete.\nThe executables and installers Lenovo bundles in their packages are generally designed to run silently and without user interaction. This means LSUClient can just execute these processes, wait for them to complete and then continue. However, it is unfortunately sometimes the case that a process LSUClient is waiting on gets stuck indefinitely and never exits on its own.\nStarting with Version 1.4.2, LSUClient will log warnings about any long-running processes at regular intervals so that such problem cases can be easily identified.\nIf you run into this, you should proceed with these two options:\nFixing hanging processes # It is always ideal to have a process finish successfully instead of hanging.\nFirst, if you run LSUClient remotely or in an unattended scenario, make sure you are only installing packages that can be installed silently and non-interactively in the first place as covered in the best practices article.\nOften when a process is stuck indefinitely, it is because it did not run entirely silently, opened up a graphical window and is waiting for user input to continue. When this happens it can easily be seen by someone in front of the computer, but to also make identifying this behavior remotely easier (without being in front of the computer), when a process has been running for longer than 5 minutes LSUClient starts checking for any open windows and if there are any, captures and prints their text contents to the console. An example output of this can be found below. The messages in the open windows often explain or can be googled to understand why the problem occurred. Sometimes a process may also leave logfiles that can help troubleshoot the cause of the hanging.\nThe feature of looking for open windows of a process run by LSUClient was first introduced in version 1.5.0. Then, the check only ran once when and *if* the process hit its configured runtime limit. Starting with LSUClient 1.5.3, all processes are investigated periodically once they've been running for longer than 5 minutes, independently of a configured runtime limit. You can also search the issues on GitHub for the package name and keywords like \u0026ldquo;hang\u0026rdquo; or \u0026ldquo;stuck\u0026rdquo; to see if other people have had the same problem. For example, GitHub issue #49 details a problem and solution with an Intel Graphics Driver installer that, despite being run in silent mode, pops up an error message under certain conditions and then sits there indefinitely.\nHanging processes in session 0 # An additional complication is if you run LSUClient (and therefore its child-processes as well) in session 0. Many software deployment solutions, MDMs, RMMs and other tools you may use to run your LSUClient scripts will run them from a service in session 0. Graphical windows can be created but are not drawn/rendered in session 0 so if a process is running there and gets stuck due to opening a window and waiting for someone to interact with it, the window will not be visible and only a limited set of information about it (such as its dimensions) can even be gathered by LSUClient. Any text inside a window cannot be retrieved and attempts to screenshot the window only show black. If you run LSUClient in session 0 and experience hanging processes, it is best to reproduce the problem running LSUClient in a graphical logon session (such as via RDP or in front of the physical device) to ensure any opened windows and their contents are fully drawn and visible. When running with the -Debug parameter, LSUClient prints the session ID it and processes started by it are running in, e.g.:\n... DEBUG: Process IDs in job (without runspace): 14076 DEBUG: (Current session ID: 1, Environment.UserInteractive: True) WARNING: Process \u0026#39;C:\\Windows\\Temp\\n2hdr35w\\installer.exe\u0026#39; has been running for 00:05:00.1928042 WARNING: 14076: \u0026#39;Installer\u0026#39; started at 20:34:04.3837487 DEBUG: Process 14076 (\u0026#39;Installer\u0026#39;): DEBUG: Session: 1 DEBUG: CommandLine: \u0026#34;C:\\Windows\\Temp\\n2hdr35w\\installer.exe\u0026#34; -s DEBUG: StartTime: 20:34:04.3837487 DEBUG: Parent Id: 14384 ... Killing hanging processes # Starting with LSUClient 1.5.0, you can configure runtime limits for external processes. When a process exceeds the limit, it is forcefully terminated. Killing a running process is not ideal, but as a last resort it can be a better option than having your entire LSUClient script halt indefinitely, especially in unattended scenarios.\nThese time limits are configured with Set-LSUClientConfiguration, see the Set-LSUClientConfiguration cmdlet help for details and examples on how. You can get the current limit values with Get-LSUClientConfiguration. Some limits may be enabled by default.\nAs a precaution LSUClient does not enforce the MaxInstallerRuntime setting for BIOS and firmware update installers. However this automatic safeguard is based on package metadata such as Type, Category, Title etc. and therefore may not be perfect. If you configure a MaxInstallerRuntime, always be aware of the risk of potentially forcefully stopping an in-progress firmware update! When a package install process exceeds the MaxInstallerRuntime time limit and is killed, the FailureReason of the PackageInstallResult object returned by Install-LSUpdate will be set to PROCESS_KILLED_TIMELIMIT. When this happens you should look into what caused the process to run for so long and whether it can be fixed.\nFor example, reproducing a problem with an Intel Graphics Driver installer that was reported on GitHub now gets logged with the following output when it is killed:\nExample of a package installation exceeding the MaxInstallerRuntime # jantari@AMDESKTOP:~ └─ PS\u0026gt; Set-LSUClientConfiguration -MaxInstallerRuntime (New-TimeSpan -Minutes 6) jantari@AMDESKTOP:~ └─ PS\u0026gt; Install-LSUpdate -Package $igfx -Path C:\\Windows\\Temp -Verbose VERBOSE: Installing package n2hdr35w ... WARNING: Process \u0026#39;C:\\Windows\\Temp\\n2hdr35w\\installer.exe\u0026#39; has been running for 00:05:00.0588631 WARNING: Process has exceeded the configured runtime limit of 00:06:00 WARNING: Process has windows open, this can help troubleshoot why it timed out: WARNING: - Title: ------------------------------------------- WARNING: HandledStartupErrorWindow WARNING: - Content: ----------------------------------------- WARNING: Graphics Driver Installer WARNING: WARNING: WARNING: WARNING: The application cannot be launched. WARNING: The application is in an unauthorized location. Please move to a non-system folder. WARNING: OK WARNING: ---------------------------------------------------- WARNING: Killing process 13104 \u0026#39;Installer\u0026#39; due to exceeding time limit ... ID : n2hdr35w Title : Intel Graphics Driver - 10 (1709 or Later)/11 (21H2 or Later) Type : Driver Success : False FailureReason : PROCESS_KILLED_TIMELIMIT PendingAction : NONE ExitCode : -1 StandardOutput : StandardError : LogOutput : Runtime : 00:05:59.3823498 "},{"id":4,"href":"/LSUClient-docs/docs/topics/self-hosted-repositories/","title":"Self-Hosted Repositories","section":"Topics","content":" Self-Hosted Repositories # By default LSUClient fetches packages from the official, public Lenovo Update Catalog at https://download.lenovo.com/catalog. However, just like System Update, it also supports custom, self-hosted package repositories.\nIt is currently not possible to create or manage such a custom package repository with LSUClient. Self-hosted repositories must either be created with the \u0026ldquo;Lenovo Update Retriever\u0026rdquo; program or finagled in place manually or with your own scripts if you understand the structure (see repository formats).\nMaintaining your own package repository may be of interest if you:\nRequire offline or network-internal operation Require total control over packages distributed Want to hack around, manually edit package metadata or create your own packages If you want to run LSUClient on machines that do not have direct internet acccess, or you want to speed up package download times as you deploy the same model of computer (and download the same packages) again and again, setting up a caching proxy server may be a lower-maintenance alternative to a fully internal package repository. To retrieve packages from a custom package repository, use the Repository parameter of Get-LSUpdate and point it to your repository:\nWeb-based repository You can serve your custom repository over HTTPS (or just plain HTTP) from a webserver as static files. The webserver must accept GET and HEAD requests. POST, PUT or any other methods are not required and can be disabled or blocked. Example of retrieving packages from an internal webserver: ```powershell Get-LSUpdate -Repository 'https://pkgs.domain.tld/lenovo-drivers' ``` Filesystem-based repository You can host your custom repository via a Windows filesystem path, either local or via SMB using a network drive or UNC-path. The user account running LSUClient must have read-access to the repository. Write or Modify access is not required. Example of retrieving packages from an internal fileserver: ```powershell Get-LSUpdate -Repository '\\\\pkgs.domain.tld\\lenovo-drivers$\\' ``` Repository formats # A package repository is simply a file and directory structure with one of two specific, expected package index files in the root directory that I call Model-XML and Database-XML.\nLSUClient supports fetching packages from both of these types of repositories directly.\nModel-XML # This is the structure the official, public Lenovo repository uses. There are many XML files directly in the repository root, one for each computer-model and major-OS-version combination, using the name scheme {{ Lenovo Machine Type Model (MTM) Code }}_Win{{ Major Version }}.xml. These XML files then each contain a list of links to individual packages relevant for that system.\nI know of no automatic or official method to create a custom repository of this structure. The easiest way would be to download the XML files off of the public repository with a script and editing the \"location\" of each package to point to an internal or relative path instead of the public downloads.lenovo.com site. For example this is the \u0026ldquo;Model-XML\u0026rdquo; file for a Lenovo ThinkPad L480 (Type 20LS) running Windows 10.\nDatabase-XML # This is the repository structure that Update Retriever creates. It uses a single file named database.xml in the repository root that contains a list of all packages in the repository and the information which computer-and-OS combinations each one is for.\nThe `database.xml` package index does not preserve package Category information. This means that all packages sourced from repositories of this type will always have empty Categories. You can also create and manage a repository with Update Retriever and then serve it (its root directory) via HTTP(S). Package finding process # Assuming a ThinkPad A275, model 20KD001LGE, running Windows 10 as an example, LSUClients process for discovering packages in a repository is as follows:\n%%{init:{\"theme\":\"neutral\"}}%% flowchart TD; Start([Start]) --\u003e B{\"Does 20KD_Win10.xml exist\\nin the repository root?\"} B --\u003e |No| C{\"Does database.xml exist\\nin the repository root?\"} C --\u003e |No| F([Error: No packages found]) C --\u003e |Yes| OK[Read it and find packages] B --\u003e |Yes| H OK --\u003eG{Are there packages for\\nmodel 20KD + Windows 10?} G --\u003e|No| F G --\u003e|Yes| H[Process packages] This means that when both a database.xml file and model-and-OS-specific XML files are present in a repository, LSUClient will look for and use the Model-XML file first and then fall back to database.xml only when none was found.\n"},{"id":5,"href":"/LSUClient-docs/docs/topics/versioning/","title":"Versioning","section":"Topics","content":" Versioning # LSUClient uses a three-part version number MAJOR.MINOR.PATCH and follows SemVer 2.0.0.\nThis means you can generally expect all your scripts and integrations to keep working with any one major version (such as 1.x.x).\nThere is only ever one current release of LSUClient, there is no parallel maintenance of older releases or prior versions. As soon as a new release is out the prior one is obsoleted.\nWhat is and isn\u0026rsquo;t covered by the semantic versioning promise # Semantic versioning communicates changes in a softwares \u0026ldquo;public API\u0026rdquo;.\nFor the purpose of a PowerShell Module, the public API is the exported functions (cmdlets), classes and the returned objects.\nExplicitly exempt from this public API are:\nPrivate functions Internal classes Hidden properties Output streams other than the success stream (1) The data structure, type, name, content and behavior of these may change at any point without notice as they are only intended for internal use by LSUClient itself, or in the case of non-success output streams such as Verbose and Debug, only for logging and \u0026ldquo;human consumption\u0026rdquo; and not to support scripting workloads.\nMinor breaking changes in minor versions # I must admit, I sometimes make exceptions from this rule for breaking changes I consider to be \u0026ldquo;very very minor\u0026rdquo; in that:\nI feel they are likely not going to impact any or only very few users They are trivial to adjust for, as in the change(s) required to get everything working like before with the new version are very small An example of this is the change of the type of the URL property on the [LenovoUpdate] objects from [System.Uri] to [System.String] with Version 1.3.0. So if you were accessing a property or method unique to the [System.Uri] object, for example:\n# Pretend-script written for LSUClient 1.2.5 $OneUpdate = Get-LSUpdate -All | Select-Object -First 1 if ($OneUpdate.URL.Host -like \u0026#34;*.com\u0026#34;) { Write-Output \u0026#34;Hey! This update was sourced from a .com domain!\u0026#34; } else { Write-Output \u0026#34;Some other domain!\u0026#34; } that would have broken because once $OneUpdate.URL became a string, it no longer had a Host property.\nThis means in the code snippet above $OneUpdate.URL.Host will evaluate to $null and either always print Some other domain! or error with The property 'Host' cannot be found on this object. if you are running in PowerShell Strict Mode.\nHowever, a quick fix to get the same snippet working again could be to just cast $OneUpdate.URL back to [System.Uri]:\n# Pretend-script updated for LSUClient 1.3.0+ $OneUpdate = Get-LSUpdate -All | Select-Object -First 1 if (([Uri]$OneUpdate.URL).Host -like \u0026#34;*.com\u0026#34;) { Write-Output \u0026#34;Hey! This update was sourced from a .com domain!\u0026#34; } else { Write-Output \u0026#34;Some other domain!\u0026#34; } Any such \u0026ldquo;minor breaking change\u0026rdquo; will be noted in the release notes, and will also be accompanied by a bump of the MINOR version number.\n"},{"id":6,"href":"/LSUClient-docs/docs/cmdlets/expand-lsupdate/","title":"Expand-LSUpdate","section":"Cmdlet Reference","content":" Expand-LSUpdate # SYNOPSIS # Extracts package installers.\nSYNTAX # Expand-LSUpdate [-Package] \u0026lt;PSObject\u0026gt; [-Path \u0026lt;DirectoryInfo\u0026gt;] [-ProgressAction \u0026lt;ActionPreference\u0026gt;] [\u0026lt;CommonParameters\u0026gt;] DESCRIPTION # Extracts package installers.\nEXAMPLES # Example 1 # PS C:\\\u0026gt; {{ Add example code here }} {{ Add example description here }}\nPARAMETERS # -Package # The Lenovo package or packages whose installer to extract\nType: PSObject Parameter Sets: (All) Aliases: Required: True Position: 1 Default value: None Accept pipeline input: True (ByValue) Accept wildcard characters: False -Path # The directory containing the previously downloaded packages. Use `Save-LSUpdate` to download packages.\nType: DirectoryInfo Parameter Sets: (All) Aliases: Required: False Position: Named Default value: \u0026#34;$env:TEMP\\LSUPackages\u0026#34; Accept pipeline input: False Accept wildcard characters: False -ProgressAction # {{ Fill ProgressAction Description }}\nType: ActionPreference Parameter Sets: (All) Aliases: proga Required: False Position: Named Default value: None Accept pipeline input: False Accept wildcard characters: False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters.\nINPUTS # OUTPUTS # NOTES # RELATED LINKS # "},{"id":7,"href":"/LSUClient-docs/docs/cmdlets/get-lsuclientconfiguration/","title":"Get-LSUClientConfiguration","section":"Cmdlet Reference","content":" Get-LSUClientConfiguration # SYNOPSIS # SYNTAX # Get-LSUClientConfiguration [-ProgressAction \u0026lt;ActionPreference\u0026gt;] [\u0026lt;CommonParameters\u0026gt;] DESCRIPTION # Returns the currently active configuration options\nEXAMPLES # Example 1 # PS C:\\\u0026gt; {{ Add example code here }} {{ Add example description here }}\nPARAMETERS # -ProgressAction # {{ Fill ProgressAction Description }}\nType: ActionPreference Parameter Sets: (All) Aliases: proga Required: False Position: Named Default value: None Accept pipeline input: False Accept wildcard characters: False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters.\nINPUTS # OUTPUTS # NOTES # RELATED LINKS # "},{"id":8,"href":"/LSUClient-docs/docs/cmdlets/get-lsupdate/","title":"Get-LSUpdate","section":"Cmdlet Reference","content":" Get-LSUpdate # SYNOPSIS # Fetches available driver packages and updates for Lenovo computers\nSYNTAX # Get-LSUpdate [[-Model] \u0026lt;String\u0026gt;] [[-Proxy] \u0026lt;Uri\u0026gt;] [[-ProxyCredential] \u0026lt;PSCredential\u0026gt;] [-ProxyUseDefaultCredentials] [-All] [-IncludePhantomDevices] [[-ScratchDirectory] \u0026lt;DirectoryInfo\u0026gt;] [[-Repository] \u0026lt;String\u0026gt;] [[-MachineCharacteristicsOverride] \u0026lt;Hashtable\u0026gt;] [-NoTestApplicable] [-NoTestInstalled] [-NoTestSeverityOverride] [-FailUnsupportedDependencies] [-PassUnsupportedInstallTests] [-ProgressAction \u0026lt;ActionPreference\u0026gt;] [\u0026lt;CommonParameters\u0026gt;] DESCRIPTION # Fetches available driver packages and updates for Lenovo computers\nEXAMPLES # EXAMPLE 1 # # Get available updates for the local computer PS\u0026gt; Get-LSUpdate EXAMPLE 2 # # Get all available packages for a different computer model PS\u0026gt; Get-LSUpdate -Model 20K70000GE -All PARAMETERS # -All # Return all packages, regardless of whether they are applicable to this specific machine or whether they are already installed. E.g. this will return LTE-Modem drivers even on machines that do not have the optional LTE-Modem installed, or 32-bit drivers on a 64-bit OS. Attempting to install such inapplicable drivers will likely fail. Re-installing an already installed driver can sometimes be useful to fix a driver that got corrupted.\nType: SwitchParameter Parameter Sets: (All) Aliases: Required: False Position: Named Default value: False Accept pipeline input: False Accept wildcard characters: False -FailUnsupportedDependencies # Lenovo specifies different tests with each package to determine whether it is applicable to a machine or not. This module makes a best effort to parse, understand and check these. However, new kinds of tests may be added by Lenovo at any point and some currently in use are not supported yet either. By default, any unknown applicability tests will be treated as passed which may result in a package that is really not applicable being classified as applicable. This switch will make all unsupported applicability tests fail instead, which in turn could lead to an applicable package being detected as not applicable instead.\nType: SwitchParameter Parameter Sets: (All) Aliases: Required: False Position: Named Default value: False Accept pipeline input: False Accept wildcard characters: False -IncludePhantomDevices # Consider currently disconnected (phantom) devices as well when evaluating relevant packages.\nType: SwitchParameter Parameter Sets: (All) Aliases: Required: False Position: Named Default value: False Accept pipeline input: False Accept wildcard characters: False -MachineCharacteristicsOverride # Advanced usage: Pass a Hashtable to override information about the computer that is used to evaluate packages.\nType: Hashtable Parameter Sets: (All) Aliases: Required: False Position: 6 Default value: @{} Accept pipeline input: False Accept wildcard characters: False -Model # Specify an alternative Lenovo Computer Model to retrieve update packages for. You may want to use this together with \u0026lsquo;-All\u0026rsquo; so that packages are not filtered against your local machines configuration.\nType: String Parameter Sets: (All) Aliases: Required: False Position: 1 Default value: None Accept pipeline input: False Accept wildcard characters: False -NoTestApplicable # Do not check whether packages are applicable to the computer. The IsApplicable property of the package objects will be set to $null. This switch is only available together with -All.\nType: SwitchParameter Parameter Sets: (All) Aliases: Required: False Position: Named Default value: False Accept pipeline input: False Accept wildcard characters: False -NoTestInstalled # Do not check whether packages are already installed on the computer. The IsInstalled property of the package objects will be set to $null. This switch is only available together with -All.\nType: SwitchParameter Parameter Sets: (All) Aliases: Required: False Position: Named Default value: False Accept pipeline input: False Accept wildcard characters: False -NoTestSeverityOverride # Packages have a static severity classification, but may also contain a set of tests pertaining to currently installed hardware or drivers that, when passed, dynamically override and adjust the severity rating of a package up or down. By default, this module makes a best effort to parse, understand and check these. Use this parameter to skip all SeverityOverride tests instead and have all packages be returned with their static, default severity classification. This switch is available both with and without -All.\nType: SwitchParameter Parameter Sets: (All) Aliases: Required: False Position: Named Default value: False Accept pipeline input: False Accept wildcard characters: False -PassUnsupportedInstallTests # Lenovo specifies different tests with each package to determine whether it is already installed or not. This module makes a best effort to parse, understand and check these. However, new kinds of tests may be added by Lenovo at any point and some currently in use are not supported yet either. By default, any unknown install tests will be treated as failed which may result in a package that is already installed being classified as missing. This switch will make all unsupported install tests pass instead, which in turn could lead to a missing update being detected as installed instead.\nType: SwitchParameter Parameter Sets: (All) Aliases: Required: False Position: Named Default value: False Accept pipeline input: False Accept wildcard characters: False -ProgressAction # {{ Fill ProgressAction Description }}\nType: ActionPreference Parameter Sets: (All) Aliases: proga Required: False Position: Named Default value: None Accept pipeline input: False Accept wildcard characters: False -Proxy # Specifies the URL of a proxy server to use for the connection to the update repository.\nType: Uri Parameter Sets: (All) Aliases: Required: False Position: 2 Default value: $script:LSUClientConfiguration.Proxy Accept pipeline input: False Accept wildcard characters: False -ProxyCredential # Specifies a user account that has permission to use the proxy server that is specified by the -Proxy parameter.\nType: PSCredential Parameter Sets: (All) Aliases: Required: False Position: 3 Default value: $script:LSUClientConfiguration.ProxyCredential Accept pipeline input: False Accept wildcard characters: False -ProxyUseDefaultCredentials # Indicates that the cmdlet uses the credentials of the current user to access the proxy server that is specified by the -Proxy parameter.\nType: SwitchParameter Parameter Sets: (All) Aliases: Required: False Position: Named Default value: $script:LSUClientConfiguration.ProxyUseDefaultCredentials Accept pipeline input: False Accept wildcard characters: False -Repository # The path to a package repository. This can either be an HTTP(S) URL pointing to a webserver or a filesystem path to a directory.\nType: String Parameter Sets: (All) Aliases: Required: False Position: 5 Default value: Https://download.lenovo.com/catalog Accept pipeline input: False Accept wildcard characters: False -ScratchDirectory # The path to a directory where temporary files are downloaded to for use during the search for packages. These files are cleaned up automatically. Defaults to $env:TEMP.\nType: DirectoryInfo Parameter Sets: (All) Aliases: Required: False Position: 4 Default value: $env:TEMP Accept pipeline input: False Accept wildcard characters: False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters.\nINPUTS # OUTPUTS # LenovoPackage # NOTES # RELATED LINKS # "},{"id":9,"href":"/LSUClient-docs/docs/cmdlets/install-lsupdate/","title":"Install-LSUpdate","section":"Cmdlet Reference","content":" Install-LSUpdate # SYNOPSIS # Installs a Lenovo update package. Downloads it if not previously downloaded.\nSYNTAX # Install-LSUpdate [-Package] \u0026lt;PSObject\u0026gt; [-Path \u0026lt;DirectoryInfo\u0026gt;] [-SaveBIOSUpdateInfoToRegistry] [-Proxy \u0026lt;Uri\u0026gt;] [-ProxyCredential \u0026lt;PSCredential\u0026gt;] [-ProxyUseDefaultCredentials] [-ProgressAction \u0026lt;ActionPreference\u0026gt;] [\u0026lt;CommonParameters\u0026gt;] DESCRIPTION # Installs a Lenovo update package. Downloads it if not previously downloaded.\nEXAMPLES # Example 1 # PS C:\\\u0026gt; {{ Add example code here }} {{ Add example description here }}\nPARAMETERS # -Package # The Lenovo package object to install\nType: PSObject Parameter Sets: (All) Aliases: Required: True Position: 1 Default value: None Accept pipeline input: True (ByValue) Accept wildcard characters: False -Path # If you previously downloaded the Lenovo package to a custom directory, specify its path here so that the package can be found\nType: DirectoryInfo Parameter Sets: (All) Aliases: Required: False Position: Named Default value: \u0026#34;$env:TEMP\\LSUPackages\u0026#34; Accept pipeline input: False Accept wildcard characters: False -ProgressAction # {{ Fill ProgressAction Description }}\nType: ActionPreference Parameter Sets: (All) Aliases: proga Required: False Position: Named Default value: None Accept pipeline input: False Accept wildcard characters: False -Proxy # Specifies the URL of a proxy server to use for the connection to the update repository. Used if a package still needs to be downloaded before it can be installed.\nType: Uri Parameter Sets: (All) Aliases: Required: False Position: Named Default value: $script:LSUClientConfiguration.Proxy Accept pipeline input: False Accept wildcard characters: False -ProxyCredential # Specifies a user account that has permission to use the proxy server that is specified by the -Proxy parameter.\nType: PSCredential Parameter Sets: (All) Aliases: Required: False Position: Named Default value: $script:LSUClientConfiguration.ProxyCredential Accept pipeline input: False Accept wildcard characters: False -ProxyUseDefaultCredentials # Indicates that the cmdlet uses the credentials of the current user to access the proxy server that is specified by the -Proxy parameter.\nType: SwitchParameter Parameter Sets: (All) Aliases: Required: False Position: Named Default value: $script:LSUClientConfiguration.ProxyUseDefaultCredentials Accept pipeline input: False Accept wildcard characters: False -SaveBIOSUpdateInfoToRegistry # If a BIOS update is successfully installed, write information about it to \u0026lsquo;HKLM\\Software\\LSUClient\\BIOSUpdate\u0026rsquo;. This is useful in automated deployment scenarios, especially the \u0026lsquo;ActionNeeded\u0026rsquo; key which will tell you whether a shutdown or reboot is required to apply the BIOS update. The created registry values will not be deleted by this module, only overwritten on the next installed BIOS Update.\nType: SwitchParameter Parameter Sets: (All) Aliases: Required: False Position: Named Default value: False Accept pipeline input: False Accept wildcard characters: False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters.\nINPUTS # OUTPUTS # PackageInstallResult # NOTES # RELATED LINKS # "},{"id":10,"href":"/LSUClient-docs/docs/cmdlets/save-lsupdate/","title":"Save-LSUpdate","section":"Cmdlet Reference","content":" Save-LSUpdate # SYNOPSIS # Downloads Lenovo update packages to disk\nSYNTAX # Save-LSUpdate [-Package] \u0026lt;PSObject\u0026gt; [-Proxy \u0026lt;Uri\u0026gt;] [-ProxyCredential \u0026lt;PSCredential\u0026gt;] [-ProxyUseDefaultCredentials] [-ShowProgress] [-Force] [-Path \u0026lt;DirectoryInfo\u0026gt;] [-ProgressAction \u0026lt;ActionPreference\u0026gt;] [\u0026lt;CommonParameters\u0026gt;] DESCRIPTION # Downloads Lenovo update packages to disk\nEXAMPLES # Example 1 # PS C:\\\u0026gt; {{ Add example code here }} {{ Add example description here }}\nPARAMETERS # -Force # Redownload and overwrite packages even if the files already exist in the target path.\nType: SwitchParameter Parameter Sets: (All) Aliases: Required: False Position: Named Default value: False Accept pipeline input: False Accept wildcard characters: False -Package # The Lenovo package or packages to download\nType: PSObject Parameter Sets: (All) Aliases: Required: True Position: 1 Default value: None Accept pipeline input: True (ByValue) Accept wildcard characters: False -Path # The target directory to download the packages to. In this directory, a subfolder will be created for each downloaded package containing its files.\nType: DirectoryInfo Parameter Sets: (All) Aliases: Required: False Position: Named Default value: \u0026#34;$env:TEMP\\LSUPackages\u0026#34; Accept pipeline input: False Accept wildcard characters: False -ProgressAction # {{ Fill ProgressAction Description }}\nType: ActionPreference Parameter Sets: (All) Aliases: proga Required: False Position: Named Default value: None Accept pipeline input: False Accept wildcard characters: False -Proxy # Specifies the URL of a proxy server to use for the connection to the update repository.\nType: Uri Parameter Sets: (All) Aliases: Required: False Position: Named Default value: $script:LSUClientConfiguration.Proxy Accept pipeline input: False Accept wildcard characters: False -ProxyCredential # Specifies a user account that has permission to use the proxy server that is specified by the -Proxy parameter.\nType: PSCredential Parameter Sets: (All) Aliases: Required: False Position: Named Default value: $script:LSUClientConfiguration.ProxyCredential Accept pipeline input: False Accept wildcard characters: False -ProxyUseDefaultCredentials # Indicates that the cmdlet uses the credentials of the current user to access the proxy server that is specified by the -Proxy parameter.\nType: SwitchParameter Parameter Sets: (All) Aliases: Required: False Position: Named Default value: $script:LSUClientConfiguration.ProxyUseDefaultCredentials Accept pipeline input: False Accept wildcard characters: False -ShowProgress # Shows a progress animation during the downloading process, recommended for interactive use as downloads can be quite large and without any progress output the script may appear stuck\nType: SwitchParameter Parameter Sets: (All) Aliases: Required: False Position: Named Default value: False Accept pipeline input: False Accept wildcard characters: False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters.\nINPUTS # OUTPUTS # NOTES # RELATED LINKS # "},{"id":11,"href":"/LSUClient-docs/docs/cmdlets/set-lsuclientconfiguration/","title":"Set-LSUClientConfiguration","section":"Cmdlet Reference","content":" Set-LSUClientConfiguration # SYNOPSIS # SYNTAX # Whole (Default) # Set-LSUClientConfiguration [-InputObject] \u0026lt;LSUClientConfiguration\u0026gt; [-ProgressAction \u0026lt;ActionPreference\u0026gt;] [\u0026lt;CommonParameters\u0026gt;] Individual # Set-LSUClientConfiguration [-Proxy \u0026lt;Uri\u0026gt;] [-ProxyCredential \u0026lt;PSCredential\u0026gt;] [-ProxyUseDefaultCredential \u0026lt;Boolean\u0026gt;] [-MaxExternalDetectionRuntime \u0026lt;TimeSpan\u0026gt;] [-MaxExtractRuntime \u0026lt;TimeSpan\u0026gt;] [-MaxInstallerRuntime \u0026lt;TimeSpan\u0026gt;] [-ProgressAction \u0026lt;ActionPreference\u0026gt;] [\u0026lt;CommonParameters\u0026gt;] DESCRIPTION # Sets global configuration options for LSUClient that may affect multiple cmdlets.\nEXAMPLES # EXAMPLE 1 # # Disable the default MaxExternalDetectionRuntime PS\u0026gt; Set-LSUClientConfiguration -MaxExternalDetectionRuntime ([TimeSpan]::Zero) EXAMPLE 2 # # Set a maximum allowed installer runtime of 20 minutes PS\u0026gt; Set-LSUClientConfiguration -MaxInstallerRuntime (New-TimeSpan -Minutes 20) EXAMPLE 3 # # Disable a previously configured Proxy PS\u0026gt; Set-LSUClientConfiguration -Proxy $null EXAMPLE 4 # # Apply a previously saved or edited configuration PS\u0026gt; $config = Get-LSUClientConfiguration PS\u0026gt; # ... PS\u0026gt; $config | Set-LSUClientConfiguration PARAMETERS # -InputObject # Import and set all configuration options from an LSUClientConfiguration object.\nType: LSUClientConfiguration Parameter Sets: Whole Aliases: Required: True Position: 1 Default value: None Accept pipeline input: True (ByValue) Accept wildcard characters: False -MaxExternalDetectionRuntime # Sets a time limit for how long external detection processes can run before they\u0026rsquo;re forcefully stopped.\nType: TimeSpan Parameter Sets: Individual Aliases: Required: False Position: Named Default value: None Accept pipeline input: False Accept wildcard characters: False -MaxExtractRuntime # Sets a time limit for how long package extractions can run before they\u0026rsquo;re forcefully stopped.\nType: TimeSpan Parameter Sets: Individual Aliases: Required: False Position: Named Default value: None Accept pipeline input: False Accept wildcard characters: False -MaxInstallerRuntime # Sets a time limit for how long package installers can run before they\u0026rsquo;re forcefully stopped. As a safety measure this limit is not applied for installers of firmware or BIOS/UEFI updates.\nType: TimeSpan Parameter Sets: Individual Aliases: Required: False Position: Named Default value: None Accept pipeline input: False Accept wildcard characters: False -ProgressAction # {{ Fill ProgressAction Description }}\nType: ActionPreference Parameter Sets: (All) Aliases: proga Required: False Position: Named Default value: None Accept pipeline input: False Accept wildcard characters: False -Proxy # Set the default Proxy URL for all cmdlets to use.\nType: Uri Parameter Sets: Individual Aliases: Required: False Position: Named Default value: None Accept pipeline input: False Accept wildcard characters: False -ProxyCredential # Specifies the default Proxy user account for all cmdlets to use.\nType: PSCredential Parameter Sets: Individual Aliases: Required: False Position: Named Default value: None Accept pipeline input: False Accept wildcard characters: False -ProxyUseDefaultCredential # {{ Fill ProxyUseDefaultCredential Description }}\nType: Boolean Parameter Sets: Individual Aliases: Required: False Position: Named Default value: False Accept pipeline input: False Accept wildcard characters: False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters.\nINPUTS # OUTPUTS # NOTES # RELATED LINKS # "}]