[{"id":0,"href":"/LSUClient-docs/docs/topics/examples/","title":"Basic Examples","section":"Topics","content":"Basic Examples #  These are some examples to try out. For all available parameters and guidance on how to use them run Get-Help -Detailed on the functions in this module.\nGet available updates #  Get-LSUpdate Get and install available updates #  $updates = Get-LSUpdate $updates | Install-LSUpdate -Verbose Get and install available updates, with some simple progress output #  $updates = Get-LSUpdate $i = 1 foreach ($update in $updates) { Write-Host \u0026#34;Installing update $i of $($updates.Count): $($update.Title)\u0026#34; Install-LSUpdate -Package $update -Verbose $i++ } Install only packages that can be installed silently and non-interactively #  $updates = Get-LSUpdate | Where-Object { $_.Installer.Unattended } $updates | Save-LSUpdate -Verbose $updates | Install-LSUpdate -Verbose Filtering out non-unattended packages like this is strongly recommended when using this module in MDT, SCCM, PDQ, remote execution via PowerShell Remoting, ssh or any other situation in which you run these commands remotely or as part of an automated process. Packages with installers that are not unattended may force reboots or attempt to start a GUI setup on the machine and, if successful, halt until someone clicks through the dialogs.\nGet all available packages #  $updates = Get-LSUpdate -All By default, Get-LSUpdate only returns \u0026ldquo;needed\u0026rdquo; updates. Needed updates are those that are applicable to the system and not yet installed. If you want to retrieve all available packages instead, use Get-LSUpdate -All.\nIt is possible to filter out the unneeded packages later by looking at the IsApplicable and IsInstalled properties. The default logic is equivalent to: Get-LSUpdate -All | Where-Object { $_.IsApplicable -and -not $_.IsInstalled }.\nDownload drivers for another computer #  Get-LSUpdate -Model \u0026#39;20LS\u0026#39; -All | Save-LSUpdate -Path \u0026#39;C:\\Drivers\\20LS\u0026#39; -ShowProgress Using the -Model parameter of Get-LSUpdate you can retrieve packages for another computer model. In this case you almost always want to use -All too so that the packages found are not filtered against your computer and all packages are downloaded.\nEver since LSUClient Version 1.3.3 you can also pass full-length MTM/model names such as 20K70000GE to this parameter.\n"},{"id":1,"href":"/LSUClient-docs/docs/topics/best-practices/","title":"Best Practices","section":"Topics","content":"Best Practices #  1. Search for and install updates a few times in a loop #  Some packages and updates depend on others already being installed, so they might not show up during the first search for updates. If you want to make sure \u0026ldquo;everything\u0026rdquo; has been installed and/or updated it is best to re-run Get-LSUpdate and Install-LSUpdate a few times or until no more updates are found.\nExample This is a minimal example implementation of this best practice for demonstration purposes:\n1 2 3 4 5 6 7 8 9 10 11 12  $MaxRounds = 3 for ($Round = 1; $Round -le $MaxRounds; $Round++) { Write-Host \u0026#34;Starting round $Round\u0026#34; $updates = Get-LSUpdate Write-Host \u0026#34;$($updates.Count)updates found\u0026#34; if ($updates.Count -eq 0) { break; } $updates | Install-LSUpdate -Verbose }      2. Download all packages before starting to install any #  Installing a network (NIC, WiFi adapter) driver can cause a short loss of network connectivity. When you feed packages found by Get-LSUpdate directly to Install-LSUpdate they will each be individually downloaded and then installed, therefore a network driver installation can cause the following package downloads to fail (see GitHub issue #41). Downloading all packages you intend to install beforehand with Save-LSUpdate will prevent this potential problem.\nExample This is a minimal example implementation of this best practice for demonstration purposes:\n1 2 3 4 5 6 7 8  # Find updates $updates = Get-LSUpdate # Download them all to the local disk $updates | Save-LSUpdate # Then install $updates | Install-LSUpdate      If you download packages to a custom location with Save-LSUpdate -Path you have to pass that same path to Install-LSUpdate -Path in order for it to find the previously downloaded files. If Install-LSUpdate cannot find the expected files locally, it will still attempt to fetch them from the repository.  3. Write a logfile #  Especially when running unattended or remotely, it is crucial to have a good logfile that details what happened and allows you to find the cause of a problem in retrospect.\nIf you don\u0026rsquo;t know where to start, start with Start-Transcript to log whatever is being output to the console. If you would like more insight into what LSUClient is doing, add the common -Verbose parameter to the cmdlets you run. If you are intimately familiar with Lenovos package XML format, perhaps even the output of Get-LSUpdate -Verbose -Debug will be useful to you.\nExample This is a minimal example implementation of this best practice for demonstration purposes:\n1 2 3 4 5 6 7 8 9 10 11 12 13  Start-Transcript -LiteralPath \u0026#34;$env:TEMP\\lsuclient_$(Get-Date -Format \u0026#39;yyyyMMdd-HHmmss\u0026#39;).log\u0026#34; $updates = Get-LSUpdate -Verbose Write-Host \u0026#34;$($updates.Count)updates found\u0026#34; $i = 1 foreach ($update in $updates) { Write-Host \u0026#34;Installing update $i of $($updates.Count): $($update.Title)\u0026#34; Install-LSUpdate -Package $update -Verbose $i++ } Stop-Transcript      "},{"id":2,"href":"/LSUClient-docs/docs/topics/bios-and-firmware/","title":"BIOS/UEFI and Firmware updates","section":"Topics","content":"BIOS/UEFI and other firmware updates #  LSUClient will install BIOS/UEFI updates silently when possible.\nLike with any other package, those for which a silent installation is supported will have their .Installer.Unattended property set to $True. If you get a BIOS/UEFI update for which .Installer.Unattended is $False, that means it uses a type of installer/flasher for which either no silent install options exist or for which LSUClient doesn\u0026rsquo;t support performing silent installs yet.\nWhen you install such a non-silent package its setup routine will be invoked with the default arguments in the same way System Update would.\nLikely this will mean a graphical wizard will come up and wait for you to confirm or cancel the update.\nHandling reboots #  It is important to know that some Lenovo computers require a reboot to apply BIOS updates while other models require a shutdown - the BIOS will then wake the machine from the power-off state, apply the update and boot back into Windows. Other, non-BIOS firmware updates typically always require a reboot. So as to not interrupt a deployment or someone working, this module will never initiate reboots or shutdowns on its own, however it\u0026rsquo;s easy for you to:\n  Capture the PackageInstallResult objects returned by Install-LSUpdate, e.g.:\n[array]$results = Install-LSUpdate -Package $updates   Then test for the PendingAction values REBOOT_MANDATORY or SHUTDOWN and handle them in your script:\nif ($results.PendingAction -contains \u0026#39;REBOOT_MANDATORY\u0026#39;) { # reboot immediately or set a marker for yourself to perform the reboot shortly } if ($results.PendingAction -contains \u0026#39;SHUTDOWN\u0026#39;) { # shutdown immediately or set a marker for yourself to perform the shutdown shortly } If you prefer to loop through the updates one-by-one and handle their result immediately, you can use -eq or a switch statement:\nforeach ($update in $updates) { $result = Install-LSUpdate -Package $update switch ($result.PendingAction) { # your logic here } }   SaveBIOSUpdateInfoToRegistry Parameter #  This parameter is deprecated and only documented for the sake of helping move existing scripts away from it.\nIt may be removed in a future major release of LSUClient. Use the technique described above instead.\n There is also a -SaveBIOSUpdateInfoToRegistry parameter on Install-LSUpdate.\nPrior to version 1.4.0, this used to be the only way for LSUClient to communicate a required power cycle back to you.\nWhen Install-LSUpdate is called with this parameter and it successfully installs a BIOS update, it will write some registry keys to HKLM\\Software\\LSUClient\\BIOSUpdate, including the string ActionNeeded which will contain either \u0026quot;REBOOT\u0026quot; or \u0026quot;SHUTDOWN\u0026quot;.\nHowever, using the -SaveBIOSUpdateInfoToRegistry parameter is no longer recommended because, as the name implies, it only sets those registry keys when installing BIOS/UEFI updates and not for any other kinds of firmware updates that might require a reboot just the same.\nTo summarize the differences and aid the transition, the following table compares the values to expect in different scenarios:\n   Scenario PendingAction property \u0026ldquo;ActionNeeded\u0026rdquo; registry value set by -SaveBIOSUpdateInfoToRegistry     ThinkPad BIOS update REBOOT_MANDATORY REBOOT   ThinkCentre BIOS update SHUTDOWN SHUTDOWN   Any Reboot Type 5 update REBOOT_MANDATORY    Any Reboot Type 3 update REBOOT_SUGGESTED    Any Reboot Type 0 update NONE    Any unsuccessful update NONE     As you can see, the PendingAction property is always set and more explicit and granular in communicating whether a power cycle is needed or not.\nExcluding BIOS and/or firmware updates #  If you want to simply not install any BIOS/UEFI updates, I recommend filtering them by Type and possibly Category and Title as a fallback.\nNot all packages have type information, sometimes Type is $null so don\u0026rsquo;t rely on this property alone  Packages sourced from internal repositories created with \u0026ldquo;Lenovo Update Retriever\u0026rdquo; never have Category information.\nIn that scenario it is best to either not include BIOS updates in your repository at all or to filter them by their IDs before installing.\n Filtering out BIOS/UEFI updates:\n$updates = Get-LSUpdate | Where-Object { $_.Type -ne \u0026#39;BIOS\u0026#39; } | Where-Object { $_.Category -notmatch \u0026#34;BIOS|UEFI\u0026#34; } | Where-Object { $_.Title -notmatch \u0026#34;BIOS|UEFI\u0026#34; } Filtering out other firmware updates:\n$updates = Get-LSUpdate | Where-Object { $_.Type -ne \u0026#39;Firmware\u0026#39; } | Where-Object { $_.RebootType -ne 5 } | Where-Object { $_.Category -notlike \u0026#34;*Firmware*\u0026#34; } | Where-Object { $_.Title -notlike \u0026#34;*Firmware*\u0026#34; } Recommended reading #  https://support.lenovo.com/de/en/solutions/ht507859-bios-flashing-sccm-support-thinkcentre-thinkstation\nhttps://thinkdeploy.blogspot.com/2019/06/what-are-reboot-delayed-updates.html\n"},{"id":3,"href":"/LSUClient-docs/docs/topics/self-hosted-repositories/","title":"Self-hosted repositories","section":"Topics","content":"Self-hosted repositories #  By default LSUClient fetches packages from the official, public Lenovo Update Catalog at https://download.lenovo.com/catalog. However, just like System Update, it also supports custom, self-hosted package repositories.\nIt is currently not possible to create or manage such a custom package repository with LSUClient. Self-hosted repositories must either be created with the \u0026ldquo;Lenovo Update Retriever\u0026rdquo; program or finagled in place manually or with your own scripts if you understand the structure (see repository formats).\nMaintaining your own package repository may be of interest if you:\n Require offline or network-internal operation Require total control over packages distributed Want to hack around, manually edit package metadata or create your own packages  If you want to run LSUClient on machines that do not have direct internet acccess, or you want to speed up package download times as you deploy the same model of computer (and download the same packages) again and again, setting up a caching proxy server may be a lower-maintenance alternative to a fully internal package repository.  To retrieve packages from a custom package repository, use the Repository parameter of Get-LSUpdate and point it to your repository:\nWeb-based repository You can serve your custom repository over HTTPS (or just plain HTTP) from a webserver as static files.\nThe webserver must accept GET and HEAD requests. POST, PUT or any other methods are not required and can be disabled or blocked.\nExample of retrieving packages from an internal webserver:\nGet-LSUpdate -Repository \u0026#39;https://pkgs.domain.tld/lenovo-drivers\u0026#39; Filesystem-based repository You can host your custom repository via a Windows filesystem path, either local or via SMB using a network drive or UNC-path.\nThe user account running LSUClient must have read-access to the repository. Write or Modify access is not required.\nExample of retrieving packages from an internal fileserver:\nGet-LSUpdate -Repository \u0026#39;\\\\pkgs.domain.tld\\lenovo-drivers$\\\u0026#39;  Repository formats #  A package repository is simply a file and directory structure with one of two specific, expected package index files in the root directory that I call Model-XML and Database-XML.\nLSUClient supports fetching packages from both of these types of repositories directly.\nModel-XML #  This is the structure the official, public Lenovo repository uses. There are many XML files directly in the repository root, one for each computer-model and major-OS-version combination, using the name scheme {{ Lenovo Machine Type Model (MTM) Code }}_Win{{ Major Version }}.xml. These XML files then each contain a list of links to individual packages relevant for that system.\nI know of no automatic or official method to create a custom repository of this structure. The easiest way would be to download the XML files off of the public repository with a script and editing the \u0026ldquo;location\u0026rdquo; of each package to point to an internal or relative path instead of the public downloads.lenovo.com site.  For example this is the \u0026ldquo;Model-XML\u0026rdquo; file for a Lenovo ThinkPad L480 (Type 20LS) running Windows 10.\nDatabase-XML #  This is the repository structure that Update Retriever creates. It uses a single file named database.xml in the repository root that contains a list of all packages in the repository and the information which computer-and-OS combinations each one is for.\nThe database.xml package index does not preserve package Category information. This means that all packages sourced from repositories of this type will always have empty Categories.  Creating a Filesystem-based repository with Update Retriever and then serving that directory over HTTP(S) will currently not work with LSUClient. The database.xml file Update Retriever creates references the individual packages by a relative path containing backslashes, which are escaped to %5C in URLs rather than treated as path separators.  Package finding process #  Assuming a ThinkPad A275, model 20KD001LGE, running Windows 10 as an example, LSUClients process for discovering packages in a repository is as follows:\n mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) flowchart TD Start(Start) -- B{\"Does 20KD_Win10.xml exist\\nin the repository root?\"} B ----|No| C{\"Does database.xml exist\\nin the repository root?\"} C --|No| F(Error: No packages found) C --|Yes| OK(Read it and find packages) B -- |Yes| H OK --G{Are there packages for\\nmodel 20KD + Windows 10?} G --|No| F G --|Yes| H(Process packages) This means that when both a database.xml file and model-and-OS-specific XML files are present in a repository, LSUClient will look for and use the Model-XML file first and then fall back to database.xml only when none was found.\n"},{"id":4,"href":"/LSUClient-docs/docs/topics/versioning/","title":"Versioning","section":"Topics","content":"Versioning #  LSUClient uses a three-part version number MAJOR.MINOR.PATCH and follows SemVer 2.0.0.\nThis means you can generally expect all your scripts and integrations to keep working with any one major version (such as 1.x.x).\nThere is only ever one current release of LSUClient, there is no parallel maintenance of older releases or prior versions. As soon as a new release is out the prior one is obsoleted.\nWhat is and isn\u0026rsquo;t covered by the semantic versioning promise #  Semantic versioning communicates changes in a softwares \u0026ldquo;public API\u0026rdquo;.\nFor the purpose of a PowerShell Module, the public API is the exported functions (cmdlets), classes and the returned objects.\nExplicitly exempt from this public API are:\n Private functions Internal classes Hidden properties Output streams other than the success stream (1)  The data structure, type, name, content and behavior of these may change at any point without notice as they are only intended for internal use by LSUClient itself, or in the case of non-success output streams such as Verbose and Debug, only for logging and \u0026ldquo;human consumption\u0026rdquo; and not to support scripting workloads.\nMinor breaking changes in minor versions #  I must admit, I sometimes make exceptions from this rule for breaking changes I consider to be \u0026ldquo;very very minor\u0026rdquo; in that:\n I feel they are likely not going to impact any or only very few users They are trivial to adjust for, as in the change(s) required to get everything working again with the new version are very very small  An example of this is the change of the type of the URL property on the [LenovoUpdate] objects from [System.Uri] to [System.String] with Version 1.3.0. So if you were accessing a property or method unique to the [System.Uri] object, for example:\n# Pretend-script written for LSUClient 1.2.5 $OneUpdate = Get-LSUpdate -All | Select-Object -First 1 if ($OneUpdate.URL.Host -like \u0026#34;*.com\u0026#34;) { Write-Output \u0026#34;Hey! This update was sourced from a .com domain!\u0026#34; } else { Write-Output \u0026#34;Some other domain!\u0026#34; } that would have broken because once $OneUpdate.URL became a string, it no longer had a Host property.\nThis means in the code snippet above $OneUpdate.URL.Host will evaluate to $null and either always print Some other domain! or error with The property 'Host' cannot be found on this object. if you are running in PowerShell Strict Mode.\nHowever, a quick fix to get the same snippet working again could be to just cast $OneUpdate.URL back to [System.Uri]:\n# Pretend-script updated for LSUClient 1.3.0+ $OneUpdate = Get-LSUpdate -All | Select-Object -First 1 if (([Uri]$OneUpdate.URL).Host -like \u0026#34;*.com\u0026#34;) { Write-Output \u0026#34;Hey! This update was sourced from a .com domain!\u0026#34; } else { Write-Output \u0026#34;Some other domain!\u0026#34; } Any such \u0026ldquo;minor breaking change\u0026rdquo; will be noted in the release notes, and will also be accompanied by a bump of the MINOR version number.\n"},{"id":5,"href":"/LSUClient-docs/docs/cmdlets/get-lsupdate/","title":"Get-LSUpdate","section":"Cmdlet Reference","content":"Get-LSUpdate #  SYNOPSIS #  Fetches available driver packages and updates for Lenovo computers\nSYNTAX #  Get-LSUpdate [[-Model] \u0026lt;String\u0026gt;] [[-Proxy] \u0026lt;Uri\u0026gt;] [[-ProxyCredential] \u0026lt;PSCredential\u0026gt;] [-ProxyUseDefaultCredentials] [-All] [-IncludePhantomDevices] [[-ScratchDirectory] \u0026lt;DirectoryInfo\u0026gt;] [[-Repository] \u0026lt;String\u0026gt;] [-NoTestApplicable] [-NoTestInstalled] [-NoTestSeverityOverride] [-FailUnsupportedDependencies] [-PassUnsupportedInstallTests] [\u0026lt;CommonParameters\u0026gt;] DESCRIPTION #  {{ Fill in the Description }}\nEXAMPLES #  Example 1 #  PS C:\\\u0026gt; {{ Add example code here }} {{ Add example description here }}\nPARAMETERS #  -All #  Return all packages, regardless of whether they are applicable to this specific machine or whether they are already installed. E.g. this will return LTE-Modem drivers even on machines that do not have the optional LTE-Modem installed, or 32-bit drivers on a 64-bit OS. Attempting to install such drivers will likely fail.\nType:SwitchParameterParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:FalseAccept pipeline input:FalseAccept wildcard characters:False-FailUnsupportedDependencies #  Lenovo specifies different tests to determine whether each package is applicable to a machine or not. This module makes a best effort to parse, understand and check these. However, new kinds of tests may be added by Lenovo at any point and some currently in use are not supported yet either. By default, any unknown applicability test will be treated as passed which could result in packages that are not actually applicable being detected as applicable. This switch will make all applicability tests we can\u0026rsquo;t really check fail instead, which could lead to an applicable package being detected as not applicable instead.\nType:SwitchParameterParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:FalseAccept pipeline input:FalseAccept wildcard characters:False-IncludePhantomDevices #  Consider currently disconnected (\u0026ldquo;phantom\u0026rdquo;) devices as well when evaluating relevant packages.\nType:SwitchParameterParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:FalseAccept pipeline input:FalseAccept wildcard characters:False-Model #  Specify an alternative Lenovo Computer Model to retrieve update packages for. You may want to use this together with \u0026lsquo;-All\u0026rsquo; so that packages are not filtered against your local machines configuration.\nType:StringParameter Sets:(All)Aliases:Required:FalsePosition:1Default value:NoneAccept pipeline input:FalseAccept wildcard characters:False-NoTestApplicable #  Do not check whether packages are applicable to the computer. The IsApplicable property of the package objects will be set to $null. This switch is only available together with -All.\nType:SwitchParameterParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:FalseAccept pipeline input:FalseAccept wildcard characters:False-NoTestInstalled #  Do not check whether packages are already installed on the computer. The IsInstalled property of the package objects will be set to $null. This switch is only available together with -All.\nType:SwitchParameterParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:FalseAccept pipeline input:FalseAccept wildcard characters:False-NoTestSeverityOverride #  Packages have a static severity classification, but may also contain a set of tests pertaining to currently installed hardware or drivers that, when passed, dynamically override and adjust the severity rating of a package up or down. By default, this module makes a best effort to parse, understand and check these. Use this parameter to skip all SeverityOverride tests instead and have all packages be returned with their static, default severity classification. This switch is available both with and without -All.\nType:SwitchParameterParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:FalseAccept pipeline input:FalseAccept wildcard characters:False-PassUnsupportedInstallTests #  Lenovo specifies different tests to determine whether each package is already installed or not. This module makes a best effort to parse, understand and check these. However, new kinds of tests may be added by Lenovo at any point and some currently in use are not supported yet either. By default, any unknown install tests will be treated as failed which could result in a package that is actually installed being detected as missing. This switch will make all tests we can\u0026rsquo;t really check pass instead, which could lead to a missing update being detected as installed instead.\nType:SwitchParameterParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:FalseAccept pipeline input:FalseAccept wildcard characters:False-Proxy #  Specifies a proxy server for the connection to Lenovo. Enter the URI of a network proxy server.\nType:UriParameter Sets:(All)Aliases:Required:FalsePosition:2Default value:NoneAccept pipeline input:FalseAccept wildcard characters:False-ProxyCredential #  Specifies a user account that has permission to use the proxy server that is specified by the -Proxy parameter.\nType:PSCredentialParameter Sets:(All)Aliases:Required:FalsePosition:3Default value:NoneAccept pipeline input:FalseAccept wildcard characters:False-ProxyUseDefaultCredentials #  Indicates that the cmdlet uses the credentials of the current user to access the proxy server that is specified by the -Proxy parameter.\nType:SwitchParameterParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:FalseAccept pipeline input:FalseAccept wildcard characters:False-Repository #  The path to a package repository. This can either be a HTTP/S URL pointing to a webserver or a filesystem path to a directory.\nType:StringParameter Sets:(All)Aliases:Required:FalsePosition:5Default value:Https://download.lenovo.com/catalogAccept pipeline input:FalseAccept wildcard characters:False-ScratchDirectory #  The path to a directory where temporary files are downloaded to for use during the search for packages. Defaults to $env:TEMP.\nType:DirectoryInfoParameter Sets:(All)Aliases:Required:FalsePosition:4Default value:$env:TEMPAccept pipeline input:FalseAccept wildcard characters:FalseCommonParameters #  This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters.\nINPUTS #  OUTPUTS #  LenovoPackage #  NOTES #  RELATED LINKS #  "},{"id":6,"href":"/LSUClient-docs/docs/cmdlets/install-lsupdate/","title":"Install-LSUpdate","section":"Cmdlet Reference","content":"Install-LSUpdate #  SYNOPSIS #  Installs a Lenovo update package. Downloads it if not previously downloaded.\nSYNTAX #  Install-LSUpdate [-Package] \u0026lt;PSObject\u0026gt; [-Path \u0026lt;DirectoryInfo\u0026gt;] [-SaveBIOSUpdateInfoToRegistry] [-Proxy \u0026lt;Uri\u0026gt;] [-ProxyCredential \u0026lt;PSCredential\u0026gt;] [-ProxyUseDefaultCredentials] [\u0026lt;CommonParameters\u0026gt;] DESCRIPTION #  {{ Fill in the Description }}\nEXAMPLES #  Example 1 #  PS C:\\\u0026gt; {{ Add example code here }} {{ Add example description here }}\nPARAMETERS #  -Package #  The Lenovo package object to install\nType:PSObjectParameter Sets:(All)Aliases:Required:TruePosition:1Default value:NoneAccept pipeline input:True(ByValue)Accept wildcard characters:False-Path #  If you previously downloaded the Lenovo package to a custom directory, specify its path here so that the package can be found\nType:DirectoryInfoParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:\u0026#34;$env:TEMP\\LSUPackages\u0026#34;Accept pipeline input:FalseAccept wildcard characters:False-Proxy #  {{ Fill Proxy Description }}\nType:UriParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:NoneAccept pipeline input:FalseAccept wildcard characters:False-ProxyCredential #  {{ Fill ProxyCredential Description }}\nType:PSCredentialParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:NoneAccept pipeline input:FalseAccept wildcard characters:False-ProxyUseDefaultCredentials #  {{ Fill ProxyUseDefaultCredentials Description }}\nType:SwitchParameterParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:FalseAccept pipeline input:FalseAccept wildcard characters:False-SaveBIOSUpdateInfoToRegistry #  If a BIOS update is successfully installed, write information about it to \u0026lsquo;HKLM\\Software\\LSUClient\\BIOSUpdate\u0026rsquo;. This is useful in automated deployment scenarios, especially the \u0026lsquo;ActionNeeded\u0026rsquo; key which will tell you whether a shutdown or reboot is required to apply the BIOS update. The created registry values will not be deleted by this module, only overwritten on the next installed BIOS Update.\nType:SwitchParameterParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:FalseAccept pipeline input:FalseAccept wildcard characters:FalseCommonParameters #  This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters.\nINPUTS #  OUTPUTS #  PackageInstallResult #  NOTES #  RELATED LINKS #  "},{"id":7,"href":"/LSUClient-docs/docs/cmdlets/save-lsupdate/","title":"Save-LSUpdate","section":"Cmdlet Reference","content":"Save-LSUpdate #  SYNOPSIS #  Downloads a Lenovo update package to disk\nSYNTAX #  Save-LSUpdate [-Package] \u0026lt;PSObject\u0026gt; [-Proxy \u0026lt;Uri\u0026gt;] [-ProxyCredential \u0026lt;PSCredential\u0026gt;] [-ProxyUseDefaultCredentials] [-ShowProgress] [-Force] [-Path \u0026lt;DirectoryInfo\u0026gt;] [\u0026lt;CommonParameters\u0026gt;] DESCRIPTION #  {{ Fill in the Description }}\nEXAMPLES #  Example 1 #  PS C:\\\u0026gt; {{ Add example code here }} {{ Add example description here }}\nPARAMETERS #  -Force #  Redownload and overwrite packages even if they have already been downloaded previously\nType:SwitchParameterParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:FalseAccept pipeline input:FalseAccept wildcard characters:False-Package #  The Lenovo package or packages to download\nType:PSObjectParameter Sets:(All)Aliases:Required:TruePosition:1Default value:NoneAccept pipeline input:True(ByValue)Accept wildcard characters:False-Path #  The target directory to which to download the packages to. In this directory, a subfolder will be created for each downloaded package.\nType:DirectoryInfoParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:\u0026#34;$env:TEMP\\LSUPackages\u0026#34;Accept pipeline input:FalseAccept wildcard characters:False-Proxy #  Specifies a proxy server for the connection to Lenovo. Enter the URI of a network proxy server.\nType:UriParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:NoneAccept pipeline input:FalseAccept wildcard characters:False-ProxyCredential #  Specifies a user account that has permission to use the proxy server that is specified by the -Proxy parameter.\nType:PSCredentialParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:NoneAccept pipeline input:FalseAccept wildcard characters:False-ProxyUseDefaultCredentials #  Indicates that the cmdlet uses the credentials of the current user to access the proxy server that is specified by the -Proxy parameter.\nType:SwitchParameterParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:FalseAccept pipeline input:FalseAccept wildcard characters:False-ShowProgress #  Shows a progress animation during the downloading process, recommended for interactive use as downloads can be quite large and without any progress output the script may appear stuck\nType:SwitchParameterParameter Sets:(All)Aliases:Required:FalsePosition:NamedDefault value:FalseAccept pipeline input:FalseAccept wildcard characters:FalseCommonParameters #  This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters.\nINPUTS #  OUTPUTS #  NOTES #  RELATED LINKS #  "}]